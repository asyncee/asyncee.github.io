<html>

  <head>
  <link href="http://gmpg.org/xfn/11" rel="profile">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <meta name='yandex-verification' content='4db6105a4cf78b07' />

  <!-- Enable responsiveness on mobile devices-->
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">

  
    <meta name="description" content="Великолепный Python 3 — Обзор возможностей языка, за которые я люблю новую версию Python">
    <meta property="og:title" content="Великолепный Python 3"/>
    <meta property="og:description" content="Обзор возможностей языка, за которые я люблю новую версию Python"/>
    <meta property="og:url" content= "http://asyncee.github.io/2017/03/02/gorgeous-python-3/" />
    <meta property="og:image" content= "http://asyncee.github.io/public/favicon192.png" />
    <meta property="og:type" content="article"/>
    <meta property="og:locale" content= "ru_RU" />
    <meta property="og:article:author" content= "Stanislav Lobanov" />
    <meta property="og:article:published_time" content= "2017-03-02 00:00:00 +0300" />
  

  <title>
    
      Великолепный Python 3 &middot; Asyncee
    
  </title>

  <!-- CSS -->
  <link type="text/css" rel="stylesheet" href="/assets/main-aaa5d9ad510085a3a70a411b7eb9f873e4205b6320a2f538ac6eb731733805d6.css">

  <!-- js -->
  <script type="text/javascript" src="/assets/main-057f0c0975cf656bb1fc97caa0fbd4c2b88fb7042b3428cd656d6ca42d6bb0ac.js"></script>

  <!-- Icons -->
  <link rel="apple-touch-icon-precomposed" sizes="144x144" href="/public/favicon144.png">
  <link rel="shortcut icon" href="/public/favicon32.png">

  <!-- RSS -->
  <link rel="alternate" type="application/rss+xml" title="RSS" href="/atom.xml">
</head>


  <body>

    <div class="sidebar">
  <div class="container sidebar-sticky">

    <a href="/" class="sidebar-avatar">
      <div class="avatar">
        <img class="avatar__image" src="/public/avatar/avatar.jpg">
      </div>
    </a>

    <div class="sidebar-about">
      <h1>
        <a href="/">
          Asyncee
        </a>
      </h1>
      <p class="lead">Lobanov Stanislav</p>
    </div>

    <nav class="sidebar-nav">

      
      
        
          
        
      
        
      
        
          
        
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
        
          
        
      
        
      
    </nav>

  </div>
</div>


    <div class="content container">
      <div class="post">
  <h1 class="post-title">Великолепный Python 3</h1>
  <span class="post-date">Опубликовано

2
Марта
  
2017
</span>
  <p>В этой стате я опишу возможности Python 3,  которые облегчают жизнь разработчика. Доработок в новой версии языка действительно много, поэтому я опишу только наиболее заметные изменения. Я пишу код на python каждый день, и ежедневное использование этих возможностей приносит мне большое удовольствие. Итак, поехали!</p>

<h2 id="print-теперь-функция-а-не-оператор">print теперь функция, а не оператор</h2>

<p>Да, теперь <code class="highlighter-rouge">print</code> это функция, а не оператор, так что теперь необходимо использовать скобки: <code class="highlighter-rouge">print("string")</code>.  Сигнатура функции такая:</p>

<div class="language-python highlighter-rouge"><pre class="highlight"><code><span class="k">print</span><span class="p">(</span><span class="o">*</span><span class="n">objects</span><span class="p">,</span> <span class="n">sep</span><span class="o">=</span><span class="s">' '</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="s">'</span><span class="se">\n</span><span class="s">'</span><span class="p">,</span> <span class="nb">file</span><span class="o">=</span><span class="n">sys</span><span class="o">.</span><span class="n">stdout</span><span class="p">,</span> <span class="n">flush</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
</code></pre>
</div>

<p><a href="https://docs.python.org/3/library/functions.html#print">Подробнее в документации.</a></p>

<h2 id="unicode-поумолчанию">unicode по−умолчанию</h2>

<p>Теперь все строки в <strong>Unicode</strong> по−умолчанию, а кодировка, конечно−же, <strong>utf-8</strong>. Искренне рад этому изменению, так как можно навсегда забыть про литерал <code class="highlighter-rouge">u""</code> и писать более чистый код.</p>

<ul>
  <li><a href="https://docs.python.org/3.0/whatsnew/3.0.html#text-vs-data-instead-of-unicode-vs-8-bit">Документация по изменениям str vs unicode.</a></li>
  <li><a href="https://www.python.org/dev/peps/pep-3120/">Документация по utf-8 кодировке по−умолчанию (PEP-3120).</a></li>
</ul>

<h2 id="Числовой-тип-поумолчанию--int">Числовой тип по−умолчанию — int</h2>

<p>Да, теперь число при выполнении различных операций не может поменять свой тип и стать <code class="highlighter-rouge">long</code>, например. По−факту, <code class="highlighter-rouge">long</code> из Python 2 просто переименовали в <code class="highlighter-rouge">int</code>.</p>

<p><a href="https://www.python.org/dev/peps/pep-0237/">Документация (PEP-237).</a></p>

<h2 id="Распаковка">Распаковка</h2>

<p>В PEP-448 определены дополнительные возможности для использования операторов распаковки итератора и словаря (<code class="highlighter-rouge">*</code> и <code class="highlighter-rouge">**</code>). Их можно использовать произвольное количество раз, например:</p>

<div class="language-python highlighter-rouge"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="n">dict_a</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">:</span> <span class="s">'one'</span><span class="p">}</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">dict_b</span> <span class="o">=</span> <span class="p">{</span><span class="mi">2</span><span class="p">:</span> <span class="s">'two'</span><span class="p">}</span>
<span class="o">&gt;&gt;&gt;</span> <span class="p">{</span><span class="o">**</span><span class="n">dict_a</span><span class="p">,</span> <span class="o">**</span><span class="n">dict_b</span><span class="p">}</span>
<span class="p">{</span><span class="mi">1</span><span class="p">:</span> <span class="s">'one'</span><span class="p">,</span> <span class="mi">2</span><span class="p">:</span> <span class="s">'two'</span><span class="p">}</span>

<span class="o">&gt;&gt;&gt;</span> <span class="n">list_a</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">list_b</span> <span class="o">=</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]</span>
<span class="o">&gt;&gt;&gt;</span> <span class="p">[</span><span class="o">*</span><span class="n">list_a</span><span class="p">,</span> <span class="o">*</span><span class="n">list_b</span><span class="p">]</span>
<span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]</span>
</code></pre>
</div>

<p>Так что можно обойтись без <code class="highlighter-rouge">dict.update(another_dict)</code>. Работает, начиная с <strong>Python 3.5</strong>.</p>

<p>Ещё одно замечательное изменение в языке — расширенная распаковка. Теперь можно указать переменную, в которую будут помещены все элементы, не указанные явно. Проще пояснить на примере:</p>

<div class="language-python highlighter-rouge"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="n">a</span><span class="p">,</span> <span class="o">*</span><span class="n">other</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">]</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">a</span>
<span class="mi">1</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">other</span>
<span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">b</span>
<span class="mi">5</span>
</code></pre>
</div>

<p>Как видно, в переменную <code class="highlighter-rouge">other</code> попали все элементы, кроме первого и последнего.</p>

<p>Код стал более чистым (пример из документации):</p>

<div class="language-python highlighter-rouge"><pre class="highlight"><code><span class="c"># было</span>
<span class="n">first</span><span class="p">,</span> <span class="n">rest</span> <span class="o">=</span> <span class="n">seq</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">seq</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>

<span class="c"># стало</span>
<span class="n">first</span><span class="p">,</span> <span class="o">*</span><span class="n">rest</span> <span class="o">=</span> <span class="n">seq</span>
</code></pre>
</div>

<ul>
  <li><a href="https://www.python.org/dev/peps/pep-0448/">Документация (PEP-448).</a></li>
  <li><a href="https://www.python.org/dev/peps/pep-3132/">Документация (PEP-3132).</a></li>
</ul>

<h2 id="Настоящее-деление">Настоящее деление</h2>

<p>Наконец−то в Python 3 догадались реализовать настоящее деление. Ранее деление было неочевидным — для <code class="highlighter-rouge">int</code> и <code class="highlighter-rouge">long</code> возвращалась целая часть, а для <code class="highlighter-rouge">float</code> — приблизительный результат деления:</p>

<div class="language-python highlighter-rouge"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="mi">12</span> <span class="o">/</span> <span class="mi">7</span>
<span class="mi">1</span>
<span class="o">&gt;&gt;&gt;</span> <span class="mi">12</span> <span class="o">/</span> <span class="mf">7.0</span>
<span class="mf">1.7142857142857142</span>
</code></pre>
</div>

<p>Разумеется такое поведение по−умолчанию приводило к ошибкам в работе программ, когда на вход подавалось целое число (<code class="highlighter-rouge">int</code>, <code class="highlighter-rouge">long</code>) вместо дробного. Теперь эту ситуацию исправили и деление с помощью оператора <code class="highlighter-rouge">/</code> возвращает ожидаемый результат.</p>

<p><a href="https://www.python.org/dev/peps/pep-0238/">Документация (PEP-238).</a></p>

<h2 id="Только-ключевые-аргументы">Только ключевые аргументы</h2>

<p>PEP-3102 определяет новый вид аргументов, которые могут быть переданы в функцию только по отдельному ключевому слову, но не через позиционный параметр. Суть в том, что ранее нельзя было определить аргументы переменной длины (<code class="highlighter-rouge">*args</code>), а за ними какие−то ключевые аргументы. Это было синтаксической ошибкой. Чтобы её обойти, приходилось определять сигнатуру функции как</p>

<div class="language-python highlighter-rouge"><pre class="highlight"><code><span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</code></pre>
</div>

<p>и получать ключевые аргументы уже оттуда, например как <code class="highlighter-rouge">x = kwargs.get('x')</code>. Теперь эта проблема решена и доступна вот такая запись:</p>

<div class="language-python highlighter-rouge"><pre class="highlight"><code><span class="k">def</span> <span class="nf">a</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="k">pass</span>

<span class="k">def</span> <span class="nf">b</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="k">pass</span>
</code></pre>
</div>

<p>То есть Python 3 позволяет писать более чистый код на уровне синтаксиса языка.</p>

<p><a href="https://www.python.org/dev/peps/pep-3102/">Документация (PEP-3102).</a></p>

<h2 id="Форматируемые-строковые-литералы">Форматируемые строковые литералы</h2>

<p>С момента релиза <strong>Python 3.6</strong>, эту тему уже успели раскрыть во множестве изданий, поэтому подробно останавливаться на ней не буду. Суть в том, что строки можно форматировать, определяя подстановки в самой строке и работать это будет точно так же, как если был вызван метод <code class="highlighter-rouge">format</code>:</p>

<div class="language-python highlighter-rouge"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="n">name</span> <span class="o">=</span> <span class="s">"Fred"</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">f</span><span class="s">"He said his name is {name}."</span>
<span class="s">'He said his name is Fred.'</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">width</span> <span class="o">=</span> <span class="mi">10</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">precision</span> <span class="o">=</span> <span class="mi">4</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">value</span> <span class="o">=</span> <span class="n">decimal</span><span class="o">.</span><span class="n">Decimal</span><span class="p">(</span><span class="s">"12.34567"</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">f</span><span class="s">"result: {value:{width}.{precision}}"</span>  <span class="c"># nested fields</span>
<span class="s">'result:      12.35'</span>
</code></pre>
</div>

<p><a href="https://www.python.org/dev/peps/pep-0498/">Документация (PEP-498).</a></p>

<h2 id="Подчёркивания-в-числах">Подчёркивания в числах</h2>

<p>Возможно эта возможность в языке совсем и незначительная, но мне она очень нравится, так как теперь можно приводить большие числа в более читаемый вид:</p>

<div class="language-python highlighter-rouge"><pre class="highlight"><code><span class="c"># было</span>
<span class="n">a</span> <span class="o">=</span> <span class="mi">1000000</span>

<span class="c"># стало</span>
<span class="n">b</span> <span class="o">=</span> <span class="mi">1</span><span class="n">_000_000</span>
</code></pre>
</div>

<p><a href="https://www.python.org/dev/peps/pep-0515/">Документация (PEP-515).</a></p>

<h2 id="Новая-реализация-словарей">Новая реализация словарей</h2>

<p>Начиная с <strong>Python 3.6</strong> появилась новая реализация словарей, которая уменьшает объём потребляемой памяти на 20-25% по сравнению с версией 3.5.</p>

<p>Так же реализация словаря в <em>Python 3.6</em> сохраняет порядок атрибутов, но это всего лишь деталь реализации интерпретатора <em>CPython</em>. То есть, в <em>Pypy</em> или любой другой версии интерпретатора словарь может быть не упорядоченным, что приведёт к ошибкам в программе.</p>

<p>Однако теперь гарантируется сохранение порядка определения атрибутов, а так же порядок элементов в <code class="highlighter-rouge">**kwargs</code> соответствует порядку, в котором эти элементы переданы в функцию.</p>

<p><a href="https://docs.python.org/3/whatsnew/3.6.html#pep-520-preserving-class-attribute-definition-order">Подробнее в документации.</a></p>

<h2 id="Возможность-модификации-подкласса-без-использования-метаклассов">Возможность модификации подкласса без использования метаклассов</h2>

<p>Появилась возможность писать классы, которые изменяют поведение своих подклассов. По сути, этот функционал похож на написание декоратора класса, с тем отличием, что влияет он на все будущие подклассы, а не на один конкретный класс. Суть в том, что какие−то простые вещи, такие как, реестр подклассов, теперь можно реализовать без использования метаклассов.</p>

<div class="language-python highlighter-rouge"><pre class="highlight"><code><span class="k">class</span> <span class="nc">PluginBase</span><span class="p">:</span>
    <span class="n">_plugins</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="k">def</span> <span class="nf">__init_subclass__</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">cls</span><span class="o">.</span><span class="n">_plugins</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">cls</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">__init_subclass__</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">get_plugin</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">cls</span><span class="o">.</span><span class="n">_known_plugins</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>

<span class="k">class</span> <span class="nc">FooPlugin</span><span class="p">(</span><span class="n">Plugin</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s">"foo_plugin"</span><span class="p">):</span>
    <span class="k">pass</span>
</code></pre>
</div>

<p>В данном примере, при инициализации подкласса <code class="highlighter-rouge">FooPlugin</code>, выполняется метод <code class="highlighter-rouge">__init_subclass__</code>. Переменная <code class="highlighter-rouge">cls</code> указывает на сам инициализируемый подкласс. Далее информация о новом подклассе записывается в переменную <code class="highlighter-rouge">_plugins</code> базового класса (см. <a href="https://docs.python.org/3.6/reference/datamodel.html">Python Data Model</a> / method resolution order). Ну, и обратите внимание, что при инициализации подкласса на его поведение можно влиять с помощью параметров <code class="highlighter-rouge">**kwargs</code>.</p>

<p><a href="https://docs.python.org/3/reference/datamodel.html#class-customization">Документация.</a></p>

<h2 id="Заключение">Заключение</h2>

<p>На самом деле в Python есть огромное количество других нововведений и улучшений, но в данной статье я перечислил только самые важные для меня. За кадром остались <code class="highlighter-rouge">type hints</code>, <code class="highlighter-rouge">new style classes</code>, улучшения в поддержке асинхронного программирования и много чего ещё. Для ознакомления с ними рекомендую почитать <a href="https://docs.python.org/3/whatsnew/">What’s new in Python</a>, там действительно много интересного.</p>

</div>

<div id="disqus_thread"></div>
<script>

var disqus_config = function () {
this.page.url = "http://asyncee.github.io/2017/03/02/gorgeous-python-3/";  // Replace PAGE_URL with your page's canonical URL variable
this.page.identifier = "/2017/03/02/gorgeous-python-3/"; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
};
(function() { // DON'T EDIT BELOW THIS LINE
var d = document, s = d.createElement('script');
s.src = '//asyncee-github-io.disqus.com/embed.js';
s.setAttribute('data-timestamp', +new Date());
(d.head || d.body).appendChild(s);
})();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>


    </div>

        <!-- Yandex.Metrika counter -->
    <script type="text/javascript">
        (function (d, w, c) {
            (w[c] = w[c] || []).push(function() {
                try {
                    w.yaCounter36001570 = new Ya.Metrika({
                        id:36001570,
                        clickmap:true,
                        trackLinks:true,
                        accurateTrackBounce:true,
                        webvisor:true
                    });
                } catch(e) { }
            });

            var n = d.getElementsByTagName("script")[0],
                s = d.createElement("script"),
                f = function () { n.parentNode.insertBefore(s, n); };
            s.type = "text/javascript";
            s.async = true;
            s.src = "https://mc.yandex.ru/metrika/watch.js";

            if (w.opera == "[object Opera]") {
                d.addEventListener("DOMContentLoaded", f, false);
            } else { f(); }
        })(document, window, "yandex_metrika_callbacks");
    </script>
    <noscript><div><img src="https://mc.yandex.ru/watch/36001570" style="position:absolute; left:-9999px;" alt="" /></div></noscript>
    <!-- /Yandex.Metrika counter -->


    <!-- JS -->
    <script async src="/public/js/medium-zoom.min.js" onload="initMediumZoom()"></script>
    <link href="https://fonts.googleapis.com/css?family=Abril+Fatface|Lora:400,400i,700|Roboto:500|Roboto+Mono&amp;subset=cyrillic" rel="stylesheet">
  </body>
</html>
