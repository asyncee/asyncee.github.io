<!DOCTYPE html>
<html prefix="
og: http://ogp.me/ns# article: http://ogp.me/ns/article#
" vocab="http://ogp.me/ns" lang="ru">
<head>
<meta charset="utf-8">
<meta name="description" content="Обзор возможностей языка, за которые я люблю новую версию Python">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Asyncee · Великолепный Python 3 </title>
<link href="../../assets/css/all.css" rel="stylesheet" type="text/css">
<link rel="stylesheet" href="http://fonts.googleapis.com/css?family=PT+Sans:400,400italic,700%7CAbril+Fatface">
<meta content="#5670d4" name="theme-color">
<link rel="alternate" type="application/rss+xml" title="RSS" href="../../rss.xml">
<link rel="canonical" href="https://asyncee.github.io/posts/gorgeous-python-3/">
<!--[if lt IE 9]><script src="../../assets/js/html5.js"></script><![endif]--><meta name="yandex-verification" content="4db6105a4cf78b07">
<link href="https://fonts.googleapis.com/css?family=Abril+Fatface%7CLora:400,400i,700%7CRoboto:500%7CRoboto+Mono&amp;subset=cyrillic" rel="stylesheet">
<meta name="author" content="Stanislav Lobanov">
<link rel="prev" href="../moving-to-jekyll/" title="Про Lektor" type="text/html">
<link rel="next" href="../how-to-configure-flake-8-with-pycharm-2016-3/" title="Как настроить flake8 для работы в Pycharm 2016.3" type="text/html">
<meta property="og:site_name" content="Asyncee">
<meta property="og:title" content="Великолепный Python 3">
<meta property="og:description" content="Обзор возможностей языка, за которые я люблю новую версию Python">
<meta property="og:url" content="https://asyncee.github.io/posts/gorgeous-python-3/">
<meta property="og:type" content="article">
<meta property="og:locale" content="ru_RU">
<meta property="og:article:published_time" content="2017-03-02T23:00:00+03:00">
</head>
<body class="">
    <a href="#content" class="sr-only sr-only-focusable">Перейти к главному содержимому</a>

    <div class="hsidebar">
        <div class="container sidebar-sticky">
            <div class="sidebar-about">
                <h1 id="brand"><a href="https://asyncee.github.io/" title="Asyncee" rel="home">

        <span id="blog-title">Asyncee</span>
    </a></h1>

                <p class="lead">Stanislav Lobanov</p>

            </div>

            <div id="menuToggle">
                <input type="checkbox"><span></span>
                <span></span>
                <span></span>

                    <nav id="menu" role="navigation" class="sidebar-nav"><a class="sidebar-nav-item" href="../../archive.html">Архив</a>
        <a class="sidebar-nav-item" href="../../categories/">Тэги</a>
        <a class="sidebar-nav-item" href="../../rss.xml">RSS лента</a>
    
    
    </nav>
</div>

            
        </div>
    </div>

    <div class="content container" id="content">
<article class="post-text h-entry hentry postpage" itemscope="itemscope" itemtype="http://schema.org/Article"><h1 class="post-title p-name"><a href="." class="u-url">Великолепный Python 3</a></h1>

    <span class="post-date">
      <time class="published dt-published" datetime="2017-03-02T23:00:00+03:00" itemprop="datePublished" title="Опубликовано 02 марта 2017">Опубликовано 02 марта 2017</time></span>
        <meta name="description" itemprop="description" content="Обзор возможностей языка, за которые я люблю новую версию Python">
<div class="e-content entry-content" itemprop="articleBody text">
    <div>
<p>В этой стате я опишу возможности Python 3,  которые облегчают жизнь разработчика. Доработок в новой версии языка действительно много, поэтому я опишу только наиболее заметные изменения. Я пишу код на python каждый день, и ежедневное использование этих возможностей приносит мне большое удовольствие. Итак, поехали!</p>
<h3>print теперь функция, а не оператор</h3>
<p>Да, теперь <code>print</code> это функция, а не оператор, так что теперь необходимо использовать скобки: <code>print("string")</code>.  Сигнатура функции такая:</p>
<pre class="code literal-block"><span></span><span class="k">print</span><span class="p">(</span><span class="o">*</span><span class="n">objects</span><span class="p">,</span> <span class="n">sep</span><span class="o">=</span><span class="s1">' '</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="s1">'</span><span class="se">\n</span><span class="s1">'</span><span class="p">,</span> <span class="nb">file</span><span class="o">=</span><span class="n">sys</span><span class="o">.</span><span class="n">stdout</span><span class="p">,</span> <span class="n">flush</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
</pre>


<p><a href="https://docs.python.org/3/library/functions.html#print">Подробнее в документации.</a></p>
<h3>unicode по−умолчанию</h3>
<p>Теперь все строки в <strong>Unicode</strong> по−умолчанию, а кодировка, конечно−же, <strong>utf-8</strong>. Искренне рад этому изменению, так как можно навсегда забыть про литерал <code>u""</code> и писать более чистый код.</p>
<ul>
<li><a href="https://docs.python.org/3.0/whatsnew/3.0.html#text-vs-data-instead-of-unicode-vs-8-bit">Документация по изменениям str vs unicode.</a></li>
<li><a href="https://www.python.org/dev/peps/pep-3120/">Документация по utf-8 кодировке по−умолчанию (PEP-3120).</a></li>
</ul>
<h3>Числовой тип по−умолчанию — int</h3>
<p>Да, теперь число при выполнении различных операций не может поменять свой тип и стать <code>long</code>, например. По−факту, <code>long</code> из Python 2 просто переименовали в <code>int</code>.</p>
<p><a href="https://www.python.org/dev/peps/pep-0237/">Документация (PEP-237).</a></p>
<h3>Распаковка</h3>
<p>В PEP-448 определены дополнительные возможности для использования операторов распаковки итератора и словаря (<code>*</code> и <code>**</code>). Их можно использовать произвольное количество раз, например:</p>
<pre class="code literal-block"><span></span><span class="o">&gt;&gt;&gt;</span> <span class="n">dict_a</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">:</span> <span class="s1">'one'</span><span class="p">}</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">dict_b</span> <span class="o">=</span> <span class="p">{</span><span class="mi">2</span><span class="p">:</span> <span class="s1">'two'</span><span class="p">}</span>
<span class="o">&gt;&gt;&gt;</span> <span class="p">{</span><span class="o">**</span><span class="n">dict_a</span><span class="p">,</span> <span class="o">**</span><span class="n">dict_b</span><span class="p">}</span>
<span class="p">{</span><span class="mi">1</span><span class="p">:</span> <span class="s1">'one'</span><span class="p">,</span> <span class="mi">2</span><span class="p">:</span> <span class="s1">'two'</span><span class="p">}</span>

<span class="o">&gt;&gt;&gt;</span> <span class="n">list_a</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">list_b</span> <span class="o">=</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]</span>
<span class="o">&gt;&gt;&gt;</span> <span class="p">[</span><span class="o">*</span><span class="n">list_a</span><span class="p">,</span> <span class="o">*</span><span class="n">list_b</span><span class="p">]</span>
<span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]</span>
</pre>


<p>Так что можно обойтись без <code>dict.update(another_dict)</code>. Работает, начиная с <strong>Python 3.5</strong>.</p>
<p>Ещё одно замечательное изменение в языке — расширенная распаковка. Теперь можно указать переменную, в которую будут помещены все элементы, не указанные явно. Проще пояснить на примере:</p>
<pre class="code literal-block"><span></span><span class="o">&gt;&gt;&gt;</span> <span class="n">a</span><span class="p">,</span> <span class="o">*</span><span class="n">other</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">]</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">a</span>
<span class="mi">1</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">other</span>
<span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">b</span>
<span class="mi">5</span>
</pre>


<p>Как видно, в переменную <code>other</code> попали все элементы, кроме первого и последнего.</p>
<p>Код стал более чистым (пример из документации):</p>
<pre class="code literal-block"><span></span><span class="c1"># было</span>
<span class="n">first</span><span class="p">,</span> <span class="n">rest</span> <span class="o">=</span> <span class="n">seq</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">seq</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>

<span class="c1"># стало</span>
<span class="n">first</span><span class="p">,</span> <span class="o">*</span><span class="n">rest</span> <span class="o">=</span> <span class="n">seq</span>
</pre>


<ul>
<li><a href="https://www.python.org/dev/peps/pep-0448/">Документация (PEP-448).</a></li>
<li><a href="https://www.python.org/dev/peps/pep-3132/">Документация (PEP-3132).</a></li>
</ul>
<h3>Настоящее деление</h3>
<p>Наконец−то в Python 3 догадались реализовать настоящее деление. Ранее деление было неочевидным — для <code>int</code> и <code>long</code> возвращалась целая часть, а для <code>float</code> — приблизительный результат деления:</p>
<pre class="code literal-block"><span></span><span class="o">&gt;&gt;&gt;</span> <span class="mi">12</span> <span class="o">/</span> <span class="mi">7</span>
<span class="mi">1</span>
<span class="o">&gt;&gt;&gt;</span> <span class="mi">12</span> <span class="o">/</span> <span class="mf">7.0</span>
<span class="mf">1.7142857142857142</span>
</pre>


<p>Разумеется такое поведение по−умолчанию приводило к ошибкам в работе программ, когда на вход подавалось целое число (<code>int</code>, <code>long</code>) вместо дробного. Теперь эту ситуацию исправили и деление с помощью оператора <code>/</code> возвращает ожидаемый результат.</p>
<p><a href="https://www.python.org/dev/peps/pep-0238/">Документация (PEP-238).</a></p>
<h3>Только ключевые аргументы</h3>
<p>PEP-3102 определяет новый вид аргументов, которые могут быть переданы в функцию только по отдельному ключевому слову, но не через позиционный параметр. Суть в том, что ранее нельзя было определить аргументы переменной длины (<code>*args</code>), а за ними какие−то ключевые аргументы. Это было синтаксической ошибкой. Чтобы её обойти, приходилось определять сигнатуру функции как</p>
<pre class="code literal-block"><span></span><span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre>


<p>и получать ключевые аргументы уже оттуда, например как <code>x = kwargs.get('x')</code>. Теперь эта проблема решена и доступна вот такая запись:</p>
<pre class="code literal-block"><span></span><span class="k">def</span> <span class="nf">a</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="k">pass</span>

<span class="k">def</span> <span class="nf">b</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="k">pass</span>
</pre>


<p>То есть Python 3 позволяет писать более чистый код на уровне синтаксиса языка.</p>
<p><a href="https://www.python.org/dev/peps/pep-3102/">Документация (PEP-3102).</a></p>
<h3>Форматируемые строковые литералы</h3>
<p>С момента релиза <strong>Python 3.6</strong>, эту тему уже успели раскрыть во множестве изданий, поэтому подробно останавливаться на ней не буду. Суть в том, что строки можно форматировать, определяя подстановки в самой строке и работать это будет точно так же, как если был вызван метод <code>format</code>:</p>
<pre class="code literal-block"><span></span><span class="o">&gt;&gt;&gt;</span> <span class="n">name</span> <span class="o">=</span> <span class="s2">"Fred"</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">f</span><span class="s2">"He said his name is {name}."</span>
<span class="s1">'He said his name is Fred.'</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">width</span> <span class="o">=</span> <span class="mi">10</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">precision</span> <span class="o">=</span> <span class="mi">4</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">value</span> <span class="o">=</span> <span class="n">decimal</span><span class="o">.</span><span class="n">Decimal</span><span class="p">(</span><span class="s2">"12.34567"</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">f</span><span class="s2">"result: {value:{width}.{precision}}"</span>  <span class="c1"># nested fields</span>
<span class="s1">'result:      12.35'</span>
</pre>


<p><a href="https://www.python.org/dev/peps/pep-0498/">Документация (PEP-498).</a></p>
<h3>Подчёркивания в числах</h3>
<p>Возможно эта возможность в языке совсем и незначительная, но мне она очень нравится, так как теперь можно приводить большие числа в более читаемый вид:</p>
<pre class="code literal-block"><span></span><span class="c1"># было</span>
<span class="n">a</span> <span class="o">=</span> <span class="mi">1000000</span>

<span class="c1"># стало</span>
<span class="n">b</span> <span class="o">=</span> <span class="mi">1</span><span class="n">_000_000</span>
</pre>


<p><a href="https://www.python.org/dev/peps/pep-0515/">Документация (PEP-515).</a></p>
<h3>Новая реализация словарей</h3>
<p>Начиная с <strong>Python 3.6</strong> появилась новая реализация словарей, которая уменьшает объём потребляемой памяти на 20-25% по сравнению с версией 3.5.</p>
<p>Так же реализация словаря в <em>Python 3.6</em> сохраняет порядок атрибутов, но это всего лишь деталь реализации интерпретатора <em>CPython</em>. То есть, в <em>Pypy</em> или любой другой версии интерпретатора словарь может быть не упорядоченным, что приведёт к ошибкам в программе.</p>
<p>Однако теперь гарантируется сохранение порядка определения атрибутов, а так же порядок элементов в <code>**kwargs</code> соответствует порядку, в котором эти элементы переданы в функцию.</p>
<p><a href="https://docs.python.org/3/whatsnew/3.6.html#pep-520-preserving-class-attribute-definition-order">Подробнее в документации.</a></p>
<h3>Возможность модификации подкласса без использования метаклассов</h3>
<p>Появилась возможность писать классы, которые изменяют поведение своих подклассов. По сути, этот функционал похож на написание декоратора класса, с тем отличием, что влияет он на все будущие подклассы, а не на один конкретный класс. Суть в том, что какие−то простые вещи, такие как, реестр подклассов, теперь можно реализовать без использования метаклассов.</p>
<pre class="code literal-block"><span></span><span class="k">class</span> <span class="nc">PluginBase</span><span class="p">:</span>
    <span class="n">_plugins</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="k">def</span> <span class="nf">__init_subclass__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="bp">cls</span><span class="o">.</span><span class="n">_plugins</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="bp">cls</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">__init_subclass__</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">get_plugin</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_known_plugins</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>

<span class="k">class</span> <span class="nc">FooPlugin</span><span class="p">(</span><span class="n">Plugin</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s2">"foo_plugin"</span><span class="p">):</span>
    <span class="k">pass</span>
</pre>


<p>В данном примере, при инициализации подкласса <code>FooPlugin</code>, выполняется метод <code>__init_subclass__</code>. Переменная <code>cls</code> указывает на сам инициализируемый подкласс. Далее информация о новом подклассе записывается в переменную <code>_plugins</code> базового класса (см. <a href="https://docs.python.org/3.6/reference/datamodel.html">Python Data Model</a> / method resolution order). Ну, и обратите внимание, что при инициализации подкласса на его поведение можно влиять с помощью параметров <code>**kwargs</code>.</p>
<p><a href="https://docs.python.org/3/reference/datamodel.html#class-customization">Документация.</a></p>
<h3>Заключение</h3>
<p>На самом деле в Python есть огромное количество других нововведений и улучшений, но в данной статье я перечислил только самые важные для меня. За кадром остались <code>type hints</code>, <code>new style classes</code>, улучшения в поддержке асинхронного программирования и много чего ещё. Для ознакомления с ними рекомендую почитать <a href="https://docs.python.org/3/whatsnew/">What's new in Python</a>, там действительно много интересного.</p>
</div>
    </div>
    <aside class="postpromonav"><nav></nav></aside><section class="comments hidden-print"><h2>Комментарии</h2>
                        <div id="disqus_thread"></div>
        <script>
        var disqus_shortname ="asyncee-github-io",
            disqus_url="https://asyncee.github.io/posts/gorgeous-python-3/",
        disqus_title="\u0412\u0435\u043b\u0438\u043a\u043e\u043b\u0435\u043f\u043d\u044b\u0439 Python 3",
        disqus_identifier="cache/posts/2017-03-02-gorgeous-python-3.html",
        disqus_config = function () {
            this.language = "ru";
        };
        (function() {
            var dsq = document.createElement('script'); dsq.async = true;
            dsq.src = 'https://' + disqus_shortname + '.disqus.com/embed.js';
            (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
        })();
    </script><noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a>
</noscript>
    <a href="https://disqus.com" class="dsq-brlink" rel="nofollow">Comments powered by <span class="logo-disqus">Disqus</span></a>


        </section></article><script>var disqus_shortname="asyncee-github-io";(function(){var a=document.createElement("script");a.async=true;a.src="https://"+disqus_shortname+".disqus.com/count.js";(document.getElementsByTagName("head")[0]||document.getElementsByTagName("body")[0]).appendChild(a)}());</script>
</div>

        <!-- Yandex.Metrika counter -->
    <script type="text/javascript">
        (function (d, w, c) {
            (w[c] = w[c] || []).push(function() {
                try {
                    w.yaCounter36001570 = new Ya.Metrika({
                        id:36001570,
                        clickmap:true,
                        trackLinks:true,
                        accurateTrackBounce:true,
                        webvisor:true
                    });
                } catch(e) { }
            });
            var n = d.getElementsByTagName("script")[0],
                s = d.createElement("script"),
                f = function () { n.parentNode.insertBefore(s, n); };
            s.type = "text/javascript";
            s.async = true;
            s.src = "https://mc.yandex.ru/metrika/watch.js";
            if (w.opera == "[object Opera]") {
                d.addEventListener("DOMContentLoaded", f, false);
            } else { f(); }
        })(document, window, "yandex_metrika_callbacks");
    </script><noscript><div><img src="https://mc.yandex.ru/watch/36001570" style="position:absolute; left:-9999px;" alt=""></div></noscript>
    <!-- /Yandex.Metrika counter -->

    <script src="../../public/js/main.js"></script><script async src="../../public/js/medium-zoom.min.js" onload="initMediumZoom()"></script>
</body>
</html>
